ECE382_lab4
===========

Mixing C and Assembly


__*Required Functionality*__
Modify your assembly drawBlock function to take in 3 values: an x coordinate, a y coordinate, and a color.

Create an etch-a-sketch program using the directional buttons of the LCD booster pack to control the position of the paint brush. The paint brush will draw 8x8 blocks of pixels. The user will change the position of the paint brush by pressing the directional buttons. Each button press will move the cursor 8 pixels in the direction pressed (see table below). Pressing the auxiliary button (SW3) will toggle the mode of the paint brush between filling squares and clearing squares.

Button	Function
SW5/Up	Move the cursor up 1 block
SW4/Down	Move the cursor down 1 block
SW2/Left	Move the cursor left 1 block
SW1/Right	Move the cursor right 1 block
SW3/Aux	Toggle the color of the paint brush
This program must be written in C and call many of the subroutines written as part of lab 3, including drawBlock and changePosition.

Mind your coding standards! Commit regularly with descriptive commit messages!

__*B Functionality*__
Create a bouncing block! This block should move across the screen with no more than 8 pixels per jump. It should bounce off the walls appropriately, similar to assignment 6. An adequate delay movement should be added between each block movement. Your starting position and starting x and y velocities should be initialized in your header, or should be randomly generated.

__*A Functionality*__
Create Pong on your display! Create a single paddle that will move up and down on one side of the display, controlled by the up and down buttons. The block will bounce off the paddle like it bounces off the wall. When the block misses hitting the paddle, the game will end.

__*Bonus Functionality*__
Each bonus functionality can be achieved in conjunction with either A or B functionality. These functionalities must be written in assembly and called by C. Each is worth 5 points.

Circle: Instead of a bouncing block, create a bouncing circular ball!

Fine movement: Instead of having the ball/paddle move in 8-pixel jumps, have it move in 1-pixel jumps.

Inverted display: With a push of the SW3 button, invert the display. Dark pixels will become light pixels, and vice versa. Instead of a bouncing dark ball, you will have a bouncing light ball.



__*Prelab*__

The following taable is data given in the C Compiler User's Guide, which given information pertinent to the lab:

|__Size__|__Signed/Unsigned__|__Type__|__Min value__|__Max value__|
|:--|:--|:--|:--|:--|
|8-bit|unsigned|unsigned char|0|255|
|8-bit|signed|signed char|-128|127|
|16-bit|unsigned|unsigned short/unsigned int|0|65,535|
|16-bit|signed|signed short/signed int|-32,768|32,767|
|32-bit|unsigned|unsigned long|0|4,294,967,295|
|32-bit|signed|signed long|-2,147,483,648|2,147,483,647|
|64-bit|unsigned|unsigned long long|0|18,446,744,073,709,551,615|
|64-bit|signed|signed long long|-9,223,372,036,854,775,808|9,223,372,036,854,775,807|

Because space is limited on microcontrollers, it is a common practice to use variables with a range suitable for the task at hand. Unfortunately, there is no standard among C compilers between the basic data types like char, short, long and the number of bits in the underlying data representation. Furthermore, when writing and reading code, it is not readily apparent how many bits are in a short or long variable. Consequently, we will write our programs using typed definitions that provide an obvious connection between the data type and the number of bits in the representation. The following table is the meaning and typedef declarations of different types in C:

|__Type__|__Meaning__|__C typedef declaration__|
|:--|:--|:--|
|int8|unsigned 8-bit value|typedef unsigned char int8|
|sint8|signed 8-bit value|typedef signed char sint8|
|int16|unsigned 16-bit value|typedef unsigned short int16|
|sint16|signed 16-bit value|typedef signed short sint16|
|int32|unsigned 32-bit value|typedef unsigned long sint32|
|sint32|signed 32-bit value|typedef signed long sint32|
|int64|unsigned 64-bit value|typedef unsigned long long int64|
|sint64|signed 64-bit value|typedef signed long long sint64|

I then made a project around simpleLab4.c. I used CCS to step through the program and examined the a, b, c, d, e variables in main, just after the call to the function `func` in line 16.

|__Iteration__|__a__|__b__|__c__|__d__|__e__|
|:--|:--|:--|:--|:--|:--|
|1st|10|9|8|7|10|
|2nd|16|15|14|13|16|
|3rd|22|21|20|19|22|
|4th|28|27|26|25|28|
|5th|34|33|32|31|34|

Then I examined the assembly code generated by the compiler. To fill in the following table with the appropriate values, I had to do a few things. Firstly, I found the code for the function `func` and wrote down the starting and ending address in the table below. Next, I identified which registers were used to pass the input parameters from main to the function. I then wrote their identities below. If it wass not clear which register held which input parameter, I tested it out! Finally, I determined which register was used to return the value from func to main.

|__Parameter__|__Value Sought__|
|:--|:--|
|Starting address of `func`|0xC0BA|
|Ending address of `func`|0xC0C6|
|Register holding w|R12|
|Register holding x|R13|
|Register holding y|R14|
|Register holding z|R15|
|Register holding return value|R12|

Afterwards, I answered the last two questions to the prelab. The role of the `extern` directive in a .c file is is "a way to explicitly declare a variable, or to force a declaration without a definition without defining a variable" (wiki "External Variable). The role of the `.global` directive in an .asm file (used in lines 28-32) is to act as an external symbol that is defined in one module but can be referenced by other modules.


__*Lab*__

To begin the Lab, I looked at the requirements and the given code. From there I worked on each functionality until they were perfect.

*Required Functionality*

To begin with the required functionality, first I observed the given C code to see how to get rid of the clearDisplay() function. When I found it, I commented it out so that when I drew on the screen, my drawing left a trail rather than deleting everything every iteration. Then I wanted to know how the drawBlock() function could delete rather than draw. I remembered from ECE382_Lab3 how to use the "nokia.asm" and knew that the drawBlock function in "nokia.asm" put `#0xFF` into R13. Because I wanted 0's in all of the bits to clear the block, I used the following code from "nokiarequired.asm" to compare a variable from a certain location in "mainrequired.c" to see if I should use `#0xFF` for if I want to draw a block and `#0x00` for if I want to delete a block:

                  mov		#1, R12
                	mov		#0x03FD, R15
                	cmp.b		#1, 0(R15)
                	jz		white
                	mov		#0xFF, R13
                	jmp		black
          white	  mov		#0x00, R13
          black	  mov.w	#0x08, R5			; loop all 8 pixel columns
          loopdB:
          	      call	#writeNokiaByte		; draw the pixels

This block of code was the only thing required for "nokiarequired.asm", but for "mainrequired.c" I needed a little more code. I included a new volatile variable to be used so that I could see where in the memory it was stored. I used `volatile unsigned char	change_press;` to be my variable to indicate whether I have pressed the AUX_BUTTON or not. The following code was also added above to see if the AUX_BUTTON was pressed or not:

          if (AUX_BUTTON == 0) {
          			while(AUX_BUTTON == 0);
          			if (change_press == TRUE){
          				change_press = FALSE;
          			} else change_press = TRUE;
          			drawBlock(y,x);
          		}

If "change_press" is true, mycompare line, `cmp.b		#1, 0(R15)`, from the "nokiarequired.asm" would make the compare equal to zero and the `#0x00` would be used instead. Until the AUX_BUTTON is pressed again and changed to false, the "change_press" will continue to be true. This concludes the required functionality of the lab.

*A/B Functionality with Bonus Features*

To begin the B functionality, I had to add an xVel and yVel to update position of the ball.

                  mov		#1, R12
                	mov		#0x03EE, R15
                	mov		#0xFF, R13
    ;CHANGE CMP -if drawpaddle is true!
                	cmp.b	#1, 0(R15)
                	jnz		paddledraw
                	mov		#0x02, R5
                	jmp		loopdB
    paddledraw	mov.w	#0x08, R5			; loop all 8 pixel columns
    loopdB:

